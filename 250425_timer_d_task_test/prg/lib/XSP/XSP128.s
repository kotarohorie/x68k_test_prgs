*==========================================================================
*
*	128 枚モード・ソーティングルーチン
*
*==========================================================================

					* a0.l = 書換用バッファ管理構造体
	movea.l	div_buff(a0),a1		* a1.l = #ラスタ分割バッファA

					*---------------------------------------
					* d0.l = 
					* d1.l = 
					* d2.w = 
					* d3.w = 
					* d4.w = 
					* d5.w = 
					* d6.l = 
					* d7.w = 連鎖数 dbcc カウンタ
					*---------------------------------------
					* a0.l = 仮バッファスキャン & チェインスキャン
					* a1.l = 転送先スキャン
					* a2.l = 
					* a3.l = 
					* a4.l = 
					* a5.l = 
					* a6.l = 
					* a7.l = チェイン先頭情報
					*---------------------------------------

	move.l	(a7)+,a0		* PR ごとの先頭アドレス
	move.w	CHAIN_OFS(a0),d7	* 連鎖数（そのまま dbcc カウンタとして使える）
	bmi.b	SORT_128_END		* いきなり連鎖数が負（終点）なら終了

*-------[ ソーティング処理ループ ]
SORT_128_LOOP_:				* ループ 2 倍展開
	asr.w	#1,d7
	bcc.b	@F			* 奇数要素数の場合は 1 個スキップ

SORT_128_LOOP:
	move.l	(a0)+,(a1)+		* x,y 転送
	move.l	(a0)+,(a1)+		* cd,pr 転送
@@:
	move.l	(a0)+,(a1)+		* x,y 転送
	move.l	(a0)+,(a1)+		* cd,pr 転送
	dbra	d7,SORT_128_LOOP

	movea.l	CHAIN_OFS-4(a0),a0	* 次の PR 鎖アドレス
	move.w	CHAIN_OFS(a0),d7	* 連鎖数（そのまま dbcc カウンタとして使える）
	bpl.b	SORT_128_LOOP_		* 連鎖数 >= 0 なら続行

	*-------[ PR 変更 ]
		move.l	(a7)+,a0		* 次の PR の先頭アドレス
		move.w	CHAIN_OFS(a0),d7	* 連鎖数（そのまま dbcc カウンタとして使える）
		bpl.b	SORT_128_LOOP_		* 連鎖数 >= 0 なら続行

SORT_128_END:


*--------------------------------------------------------------------------
*
*	最大 128 枚モード ソート後処理
*
*--------------------------------------------------------------------------

	move.l	write_struct(pc),a0		* a0.l = 書換用バッファ管理構造体
	suba.l	div_buff(a0),a1			* a1.l = 使用スプライト数 x 8
	move.w	a1,d0
	move.w	d0,buff_sp_total(a0)		* バッファナンバー別 スプライト数 x 8 改めて保存




