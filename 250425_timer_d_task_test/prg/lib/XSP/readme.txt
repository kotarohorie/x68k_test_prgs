==========================================================================
                        スプライト管理システム XSP
                         ver 2.04     by よっしん
==========================================================================




==========================================================================
                                   説明
==========================================================================

XSP は SHARP X680x0 シリーズ上で利用可能なスプライト表示管理システムです。
以下ような機能を持ちます。

1) スプライトダブラーと呼ばれる手法により、スプライトを最大 512 枚（ハード
   ウェア上限の 4 倍）表示することが可能。


2) X680x0 の PCG エリアは 256 パターン分しか存在しないが、ここに最大 32768
   パターンまでの PCG を動的に割当てて定義する。PCG の動的割当ての際、以下
   のような最適化を行う。

   ・すでに定義されている PCG は再利用する（キャッシュヒット）。

   ・新規定義用の PCG エリアが不足した場合は、現在使用されていない PCG 領
     域を検索し、定義（上書き）する。

   ・一度定義した PCG は、後でまた必要になる可能性があるのでなるべく残す。


3) X-BASIC の sp_set 関数で必要であった、スプライトナンバーの割り当て作業
   が不要になる。


4) スプライト間表示優先度を 64 段階（実質 48 段階）で指定できる。


5) 複数のスプライトを結合させ、大きな 1 枚のスプライト（複合スプライト）と
   して表示することが可能。スプライト 1 枚毎に表示関数を呼び出すよりも少な
   いオーバーヘッドで大きな物体を表示可能。複合スプライトの形状データはユー
   ザーが任意に作成できる。


6) 構造体を利用したパラメータ受け渡しが可能なスプライト表示関数が利用可能。
   C 言語から実行する場合の、パラメータ受け渡し時のオーバーヘッドを大幅に
   軽減できる。


7) トリプルバッファリングに対応している。これにより従来のダブルバッファ方
   式とは異なり、垂直同期を無視したゲームループの実行が可能になる。

   ゲームループの処理が重くなり 60fps 達成できないとき、自動的に垂直同期を
   を無視することで、一気に 30fps までフレームレートを落とすことなくループ
   を回すことが可能になる。また、1 フレーム分の表示要求を保留させることに
   より、ゲームループをダブルバッファ方式よりも 1 フレーム先行させることが
   可能で、フレームレートの安定化が期待できる。（1 フレーム先行実行は、1 
   フレームの表示遅延をもたらすので、有効化するかどうかはユーザーの判断で
   選択する。）


8) XSP と衝突することなく、ユーザー側でも垂直帰線期間割り込み及びラスタ割
   り込みを使用することが可能（ただし、割り込み設定は、XSP が提供している
   専用関数にて行うこと）。


9) PCM8A.X（philly氏作）と XSP が完全同居できるように、PCM8A.X 側の割り込
   みマスクの設定を変更する関数が別途用意されている。


10) 限界まで最適化されている。



以下のような制約事項と注意点があります。


1) スプライトを 129 枚以上表示する時、分割ラスタ上にてスプライト表示優先度
   に破綻をきたすことがある（優先度破綻を軽減する機能も実装しているが、完
   全なものではない）。


2) BG 用・スプライト用兼用の PCG の扱いが面倒である（一応可能）。


3) 表示画面サイズ 256x256 ドットモード以外には対応していない。




==========================================================================
                           XSP の使用手順の概略
==========================================================================

ここでは使用手順の概略を説明します。詳細は各関数の説明の項目、またはサンプ
ルコードをご参照下さい。


〜〜〜〜〜〜〜〜〜〜〜〜  以下、初期化時の処理  〜〜〜〜〜〜〜〜〜〜〜〜〜

手順1)・表示画面サイズ 256x256 ドットモードにする。

      ・スプライト表示を ON にする。

      ・xsp_on 関数で XSP を有効化する。


手順2)・xsp_pcgdat_set 関数で PCG データと PCG 配置管理テーブルを指定する。

      ・必要に応じ、xsp_objdat_set 関数で複合スプライト形状データを指定す
        る。

      ・必要に応じ、xsp_vertical 関数で縦画面モードに変更する。縦画面モード
        にする場合は、付属の pcg_roll90 関数を用いて、PCG データ自体も縦画
        面対応に変換する。


〜〜〜〜〜〜〜〜  以下、ゲームのメインループ中での処理  〜〜〜〜〜〜〜〜〜

手順3)・必要に応じ、xsp_vsync2 関数で垂直同期を取る。

手順4)・xsp_set 関数、xobj_set 関数等により、スプライト表示登録する。

手順5)・xsp_out 関数で、表示登録されたスプライトを一括表示する。


      （手順3）に戻る。


〜〜〜〜〜〜〜〜〜〜  以下、プログラム終了時の処理  〜〜〜〜〜〜〜〜〜〜〜

手順6)・xsp_off 関数で XSP を無効化する。


〜〜〜〜〜〜〜〜〜〜〜〜〜〜  その他、補足  〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜

・PCG データ自体を（新たにロードする等して）変更した場合は、必ず再度
  xsp_pcgdat_set 関数により指定しなおすこと。

・必要に応じ、xsp_pcgmask_on/off 関数で、XSP 管理対象外とする PCG 領域の指
  定または解除を行う（xsp_on 関数実行後なら常時可能）。

・必要に応じ、xsp_mode 関数でスプライト表示数増加アルゴリズムを指定する
  （xsp_on 関数実行後なら常時可能）。

・必要に応じ、xsp_vsync_interval_set 関数で vsync の間隔を設定する。

・必要に応じ、xsp_vsyncint_on/off 関数で、垂直帰線期間割り込み処理の設定
  /解除を行う（xsp_on 関数実行後なら常時可能）。

・必要に応じ、xsp_hsyncint_on/off 関数で、指定ラスタでの割り込み処理の設
  定/解除を行う（xsp_on 関数実行後なら常時可能）。




==========================================================================
                             関数のコール方法
==========================================================================

各関数は C 言語のコール方式のみ対応となっています。アセンブラから使用する
場合は、C 言語のコール方式に準拠して下さい。

アセンブラからの使用するユーザーのために、C 言語準拠コールの手順を説明しま
す。

手順1) レジスタ d0-d2/a0-a2 をスタックに退避する。（仮に、コールする関数内
       内にて d0-d2/a0-a2 の総てが破壊されないとしても、将来の拡張に備えて
       d0-d2/a0-a2 の総てレジスタ保護を行うこと。）


手順2) 引数を末端パラメーターから順にスタックに積む。その際、引数のデータ
       の型に関係なくすべてロングワードサイズ（32 ビット）で積むこと。


手順3) bsr または jsr 命令を用いて関数へサブルーチンジャンプする。その際指
       定するラベルは、関数名の先頭にアンダーバーを付けて記述する。

       関数から戻ってきた時点の d0 の値は戻り値となっている。戻り値の型は
       関数の型に対応している（例えば、short 型の関数の戻り値では下位 16
       ビットのみが有効な値となる）。


手順4) 手順 2 にてスタックポインタがズレているので、それを補正する。


手順5) 手順 1 で退避していたレジスタ d0-d2/a0-a2 の内容の復活を行う。


以下は、実際にアセンブラからの C 言語準拠コール例です。

    movem.l d0-d2/a0-a2,-(sp)   * レジスタ退避
    move.l  #$013F,-(sp)        * INFO
    move.l  #0,-(sp)            * PT
    move.l  #200,-(sp)          * Y
    move.l  #100,-(sp)          * X
    jsr     _xsp_set            * 関数コール（関数名に _ が必要）
                                * d0.w = 戻り値
    lea     4*4(sp),sp          * スタック補正（引数 4 つ分）
    movem.l (sp)+,d0-d2/a0-a2   * レジスタ復活

この例では、C 言語で xsp_set(100, 200, 0, 0x13F); のように記述した処理と等
価になります。




==========================================================================
                               各関数の説明
==========================================================================


● XSP の初期化

書式：void xsp_on(void);

戻り値：無し

機能：XSP の初期化を行います。初めに必ず実行するようにして下さい。

      すでに他で垂直及び水平同期割り込みが使用されていても、無視して実行さ
      れるので注意してください。



--------------------------------------------------------------------------

● XSP の終了処理

書式：void xsp_off(void);

戻り値：無し

機能：XSP を終了します。プログラム終了時に、必ず実行して下さい。さもないと
      確実に暴走します。割り込みベクタなどは、すべて XSP 初期化前の状態に
      戻されます。



--------------------------------------------------------------------------

● PCG データと PCG 配置管理テーブルを設定

書式：void xsp_pcgdat_set(const void *pcg_dat, char *pcg_alt, short alt_size);

引数：void  *pcg_dat : PCG データのポインタ
      char  *pcg_alt : PCG 配置管理テーブルのポインタ
      short alt_size : PCG 配置管理テーブルのサイズ（バイト数）

戻り値：無し


機能：PCG データと PCG 配置管理テーブルを XSP に設定します。本関数は xsp_on
      関数実行後に必ず実行して下さい。また PCG データ自体を（新たにロードす
      る等して）変更した場合は、メモリアドレスに変更が無かったとしても、必
      ず本関数により各種データを再指定して下さい。

      PCG 配置管理テーブルは、XSP が内部で使用するためのデータエリアです。
      用意した PCG データ枚数 + 1 バイトのサイズが必要です。PCG 配置管理
      テーブルの初期化（0 クリア）は本関数が自動的に行うので、ユーザーが行
      う必要はありません。

      PCG データのフォーマットは、いわゆるベタ形式です（ベタ形式のフォーマッ
      トについては後述）。スプライトツール SM.X（Oh!X 1992年6月号付録）また
      は、EEL.X（CATsoft/GORRY氏作）等でセーブした PCG データ（拡張子.SP）
      がそのまま使えます。

      なお、PCG データは偶数アドレスから置かれている必要があります。従って、
      アセンブラから使用する場合は偶数整合を必ず行なって下さい。C 言語から
      使用する場合は、初期値無しの char 型配列変数として宣言するか、short 
      型、または int 型を使用して下さい（GCC でコンパイルする場合、初期値有
      りの char 型配列変数は、スイッチの有無に関係無く偶数整合が実行されな
      いためです（真里子版 GCC VER 1.29 で確認）。

      ベタ形式 PCG データのフォーマットの構造について説明します。1 つの
      PCG は 4 つの区画に分けられます。1 つの区画は 8x8 ドットです。

                                    ↑  ┌───┬───┬───┬───┐
                                    │  │ +00  │ +01  │ +02  │ +03  │
                                    │  ├───┼───┼───┼───┤
                                    │  │ +04  │ +05  │ +06  │ +07  │
                  区画 0 拡大図     │  ├───┼───┼───┼───┤
                ┌──────→    │  │ +08  │ +09  │ +0A  │ +0B  │
                │                  │  ├───┼───┼───┼───┤
                │                      │ +0C  │ +0D  │ +0E  │ +0F  │
      ↑    ┏━━━┳━━━┓  8 ドット├───┼───┼───┼───┤
      │    ┃      ┃      ┃          │ +10  │ +11  │ +12  │ +13  │
      │    ┃区画 0┃区画 2┃      │  ├───┼───┼───┼───┤
            ┃      ┃      ┃      │  │ +14  │ +15  │ +16  │ +17  │
  16 ドット ┣━━━╋━━━┫      │  ├───┼───┼───┼───┤
            ┃      ┃      ┃      │  │ +18  │ +19  │ +1A  │ +1B  │
      │    ┃区画 1┃区画 3┃      │  ├───┼───┼───┼───┤
      │    ┃      ┃      ┃      │  │ +1C  │ +1D  │ +1E  │ +1F  │
      ↓    ┗━━━┻━━━┛      ↓  └───┴───┴───┴───┘

            ←─ 16 ドット─→          ←───── 8 ドット ─────→

      図中の各数字は、データ先頭からのオフセット（バイト単位）を 16 進数で
      表したものです。マス目 1 つで 1 バイトとなっており、各バイトの上位 4
      ビットと下位 4 ビットが、連続した 2 ドットのカラーコード（16 色）を表
      しています。従って 1 バイトあたり 2 ドットのデータ量なので、8x8ドット
      の区画あたり 32 バイトのデータ量となります。区画 1〜3 も同様となりま
      す。区画 0〜3 のデータを連続的に配置して 1 PCG 分のデータとします。
      合計 1 PCG あたり 128 バイトのデータ量となっています。

      このようなデータを、連続してメモリ上に配置して PCG データとします（下
      図）。

          +0x000┌───────┐
                │              │
                │パターン No.0 │
                │              │
          +0x080├───────┤
                │              │
                │パターン No.1 │
                │              │
          +0x100├───────┤
                │              │
                │パターン No.2 │
                │              │
          +0x180├───────┤
                ：              ：


--------------------------------------------------------------------------

● XSP 管理対象外とする PCG 領域の指定

書式：void xsp_pcgmask_on(short start_no, short end_no);

引数：short start_no：マスク設定開始 PCG ナンバー
      short end_no  ：マスク設定終了 PCG ナンバー

戻り値：無し


機能：指定した範囲の PCG エリアを、XSP の PCG 定義管理処理の対象外とするよ
      うにマスクします。本関数によりマスクされた PCG エリアは、XSP により
      上書きされるなどして破壊されることがなくなります。

      例えば既にユーザー側が BG スプライト用の PCG 定義用として使用してい
      る PCG エリアや、BG 面に割り当てられた PCG エリア（No.128〜255）が
      ある場合は、そのエリアに XSP が利用しないよう、本関数によりマスクす
      る必要があります。



--------------------------------------------------------------------------

● XSP 管理対象外とする PCG 領域の指定解除

書式：void  xsp_pcgmask_off(short start_no, short end_no);

引数：short start_no：マスク解除開始 PCG ナンバー
      short end_no  ：マスク解除終了 PCG ナンバー

戻り値：無し


機能：指定した範囲の PCG エリアに設定されたマスクを解除します。マスクの詳
      細については、xsp_pcgmask_on 関数の説明を参照して下さい。



--------------------------------------------------------------------------

● スプライト表示数増加アルゴリズムのモードを指定

書式：void xsp_mode(short mode_no);

引数：short mode_no : 1 = 128 枚点滅表示最大 384 枚モード
                      2 = 最大 512 枚モード（デフォルト）
                      3 = 最大 512 枚優先度破綻軽減モード

戻り値：無し


機能：スプライト表示数増加アルゴリズムを指定します。

      128 枚点滅表示最大 384 枚モードは、最大 128 枚のスプライトを点滅させ
      ることで、疑似的に 128 枚以上（最大 384 枚まで）表示するモードです。
      点滅処理は、表示優先度の高いスプライトを優先的に表示するように行われ
      ます。

      最大 512 枚モードは、スプライトダブラーにより、最大 512 枚のスプライ
      トが表示可能なモードです。但し、アルゴリズムの都合上、分割ラスタ上に
      てスプライトの表示優先度が破綻することがあります。

      最大 512 枚優先度破綻軽減モードは、スプライトダブラーにより、最大
      512 枚のスプライト表示を行いつつ、表示優先度の異なるスプライト間で
      の優先度破綻を軽減するモードです。ただし、スプライト表示数が多い場合
      （目安は 300 以上）や、優先度が異なる多くのスプライトが混在する場合
      優先度破綻を解消しきれなくなることがあります。また、最大 512 枚モード
      に比べ、若干の処理負荷があります。



--------------------------------------------------------------------------

● 複合スプライト形状データの指定

書式：void  xsp_objdat_set(const void *sp_ref);

引数：void *sp_ref : 複合スプライトリファレンスデータのポインタ

戻り値：無し


機能：複合スプライトの形状データ（フォーマットについては後述）を XSP に設定
      します。複合スプライトを使用する場合は、あらかじめ本関数を実行してお
      いて下さい。



--------------------------------------------------------------------------

● 垂直同期の実行（注意：obsoleted です。xsp_vsync2 を利用してください。）

書式：short xsp_vsync(short n);

引数：short n : 垂直帰線期間数

戻り値：取り逃した垂直帰線期間数
        XSP が組み込まれていなかったなら -1

機能：引数 n で示される垂直帰線期間数単位の垂直同期を行います。処理落ちが
      発生した場合は、次の垂直帰線期間まで待たない仕様となっています。ゲー
      ムのメインループ中などに組み込んで下さい。

      n に 0 を指定すると、1 フレーム先行処理状態となります。1 フレーム先
      行処理中は、急激なフレームレート変化が平滑化される効果がありますが、
      1 フレーム分の表示遅延が発生します。



--------------------------------------------------------------------------

● 垂直同期の実行

書式：short xsp_vsync2(short max_delay);

引数：short max_delay : 許容遅延フレーム数

戻り値：関数内でブロッキングしなかったら 0
        関数内でブロッキングしたら 1
        XSP が組み込まれていなかったなら -1


機能：垂直同期を行います。ゲームのメインループ中などに組み込んで下さい。

      引数 max_delay で許容遅延フレーム数を指定できます。許容遅延フレーム
      数は 0 から 2 までの範囲で指定できます。2 以上の値は 2 と同じ効果に
      なります。

      max_delay = 0 が指定された場合、垂直帰線期間に間に合わない場合、次の
      垂直帰線期間まで待ちます。
      max_delay = 1 以上が指定された場合、垂直帰線期間に間に合わない場合、
      次の垂直帰線期間まで待ちません。
      急激なフレームレート変化が起きるアプリケーションの場合、max_delay に
      大きな値を指定することで、フレームレートを安定化させることができます。
      ただし、大きな max_delay は操作系の入力遅延の原因になります。



--------------------------------------------------------------------------

● 垂直同期の間隔を指定

書式：void xsp_vsync_interval_set(short interval);

引数：short interval : 垂直同期の間隔

戻り値：無し


機能：垂直同期の間隔を指定します。

      引数 interval には 1 以上の値を指定します。0 を指定すると 1 が指定さ
      れたと見なされます。



--------------------------------------------------------------------------

● 垂直同期の間隔を取得

書式：short xsp_vsync_interval_get(void);

引数：無し

戻り値：垂直同期の間隔


機能：垂直同期の間隔を取得します。



--------------------------------------------------------------------------

● スプライトの表示登録

書式：short xsp_set(short x, short y, short pt, short info);

引数：short x    : スプライト X 座標
      short y    : スプライト Y 座標
      short pt   : スプライト PCG パターン No.（0〜0x7FFF）
      short info : 反転コード・色・表示優先度を表すデータ

戻り値：スプライト座標（x,y）が画面外だったなら 0
        それ以外の場合は 0 以外の値


機能：スプライトの表示登録を行います。表示登録されたスプライトは、xsp_out
      関数により一括表示されます。

      引数 info は、反転コード・色・表示優先度を表すデータです。16 進数
      4 桁で示され、各桁の内容は以下のようになります。

      info =  0x＊＊＊＊
                ↑↑↑↑
                ││││
                ││└┴───  表示優先度  （0〜0x3F）
                ││
                │└─────  カラーコード（0〜0xF）
                │
                └──────  反転コード    0x0：反転せず
                                              0x4：左右反転
                                              0x8：上下反転
                                              0xC：上下左右反転

      表示優先度の高いスプライトほど手前に表示されます。また、表示優先度を
      16 進数で表す場合の 2 桁目は BG との優先度を表します。具体的には以下
      のようになります。

          表示優先度 0x30〜0x3F : BG0 の上
          表示優先度 0x20〜0x2F : BG0 BG1 の間
          表示優先度 0x10〜0x1F : BG0 の下
          表示優先度 0x00〜0x0F : 表示されない



--------------------------------------------------------------------------

● 複合スプライトの表示登録

書式：void xobj_set(short x, short y, short pt, short info);

引数：short x    : 複合スプライトの X 座標
      short y    : 複合スプライトの Y 座標
      short pt   : 複合スプライトの形状パターン No.（0〜0x0FFF）
      short info : 反転コード・色・表示優先度を表すデータ

戻り値：無し


機能：複合スプライトの表示登録を行います。表示登録されたスプライトは、
      xsp_out 関数により一括表示されます。

      引数 'info' の内容は xsp_set 関数の解説を参照して下さい。

      複合スプライトの形状データ（フォーマットについては後述）は、あらかじ
      めユーザーが用意しておき、xsp_objdat_set 関数により XSP に設定してお
      いて下さい。設定せずに本関数を実行した場合、動作の保証はありません。



--------------------------------------------------------------------------

● スプライトの表示登録（構造体受け渡し）

書式：short xsp_set_st(const void *arg);

引数：void *arg : パラメータ構造体のポインタ

戻り値：スプライト座標が画面外だったなら 0
        それ以外の場合は 0 以外の値


機能：構造体経由でパラメータを受け渡す xsp_set 互換関数です。xsp_set 関数
      よりも高速に実行できます。機能の詳細については、xsp_set 関数を参照し
      て下さい。

      構造体のフォーマットは以下のようなものを用いて下さい。

        ┌────── 先頭からのオフセット（バイト数）
        │┌───── サイズ（w = ワード）
        ││    ┌── 内容
        ↓↓    ↓

        +0.w : スプライト X 座標
        +2.w : スプライト Y 座標
        +4.w : スプライト PCG パターン No.（0〜0x7FFF）
        +6.w : 反転コード・色・表示優先度を表すデータ（xsp_set 関数の、
               引数 info に相当）

      パラメータ受け渡し構造体は XSPlib.H 内で XSP_SET_ARG 型として宣言され
      ています。



--------------------------------------------------------------------------

● 複合スプライトの表示登録（構造体受け渡し）

書式：void xobj_set_st(const void *arg);

引数：void *arg : パラメータ構造体のポインタ

戻り値：無し

機能：構造体経由でパラメータを受け渡す xobj_set 互換関数です。xobj_set 関
      数よりも高速に実行できます。機能の詳細については、xobj_set 関数を参
      照して下さい。

      構造体のフォーマットは以下のようなものを用いて下さい。

        ┌────── 先頭からのオフセット（バイト数）
        │┌───── サイズ（w = ワード）
        ││    ┌── 内容
        ↓↓    ↓

        +0.w : 複合スプライトの X 座標
        +2.w : 複合スプライトの Y 座標
        +4.w : 複合スプライトの形状パターン No.（0〜0x0FFF）
        +6.w : 反転コード・色・表示優先度を表すデータ（xobj_set 関数の、
               引数 info に相当）

      パラメータ受け渡し構造体は XSPlib.H 内で XSP_SET_ARG 型として宣言され
      ています。



--------------------------------------------------------------------------

● 登録されたスプライトの一括表示

書式：short xsp_out(void);

戻り値：要求されたスプライト表示数

機能：xsp_set 関数、xobj_set 関数、xsp_set_st 関数、xobj_set_st 関数によっ
      て登録されたスプライトを一括表示します。

      xsp_pcgdat_set 関数による PCG データ等の指定、xsp_objdat_set 関数に
      よる複合スプライト形状データの指定等の初期化は、本関数実行前までに必
      ず済ませておいて下さい。必要な初期化をせず本関数を実行した場合、動作
      の保証はありません。

      なお仕様上、本関数を 1 表示期間中に 3 回以上実行しようとすると、次の
      垂直帰線期間が来るまで待たされます。



--------------------------------------------------------------------------

● 登録されたスプライトの一括表示（拡張引数付き）

書式：short xsp_out2(void *vsyncint_arg);

戻り値：要求されたスプライト表示数

機能：xsp_out 関数を機能拡張した関数です。追加引数である vsyncint_arg に渡
      された値は、本関数により要求されたスプライト表示が実行される垂直帰線
      期間割り込み処理の実行時に、第一引数として渡されます。

      XSP はスプライト表示要求を内部でバッファリングするため、xsp_out また
      は xsp_out2 関数にスプライト表示要求を出してから実際にスプライト表示
      が実行されるまで、１フレーム以上の遅延が発生します。ユーザープログラ
      ム側で、スプライト表示と同期して何らかの画面表示を行いたい場合、この
      遅延を考慮する必要があります。xsp_out2 関数の引数 vsyncint_arg を利
      用することで、遅延考慮しながら垂直帰線期間割り込みにパラメータを引き
      渡すことが可能になります。



--------------------------------------------------------------------------

● 縦画面モードの on/off を指定

書式：void xsp_vertical(short flag);

引数：short flag : 1 のとき、縦画面モード on
                   0 のとき、縦画面モード off

戻り値：無し

機能：ディスプレイを立てて使う縦画面モードの、on/off を指定します。ディス
      プレイを立てて使うことは、ディスプレイの寿命を縮めることになる可能性
      があります。十分に注意した上で各自の責任の上で行なってください。

      縦画面モードでは、ディスプレイは左を下にして使用して下さい（X68K 版
      ドラゴンスピリットと同じです）。PCG データもそれに対応するように描き
      換えて、xsp_pcgdat_set 関数で再度指定して下さい（PCG データを 90 度
      回転させる関数も、別途用意されています）。



--------------------------------------------------------------------------

● ユーザー独自の垂直帰線期間割り込み処理の設定

書式：void xsp_vsyncint_on(void *proc);

引数：void *proc : 割り込み処理関数（またはサブルーチン）のポインタ

戻り値：無し

機能：ユーザー独自の垂直帰線期間割り込み処理の設定をします。ここで指定され
      た割り込み処理関数は、XSP 内から帰線期間割り込みと同時に実行されます。

      指定する割り込み処理関数は一般の C 言語関数で良く、GCC の拡張機能に
      より割り込み処理用に記述された関数である必要はありません。アセンブ
      ラで記述したサブルーチンを割り込み処理ルーチンとして指定する場合は、
      そのサブルーチンの終わりは rte 命令でなく rts 命令として下さい。また
      サブルーチンの前後でのレジスタ退避復帰は一切必要ありません。

      なお、ユーザー指定の帰線期間割り込み処理は、なるべく処理負荷の軽いも
      のにして下さい。割り込み処理が長引き、表示期間に突入してもその処理が
      終了していないような場合、スプライト表示に支障を来すなどの弊害を生じ
      ます。



--------------------------------------------------------------------------

● ユーザー独自の垂直帰線期間割り込み処理の設定を解除

書式：void xsp_vsyncint_off(void);

戻り値：無し

機能：xsp_vsyncint_on 関数により指定された、ユーザー独自の帰線期間割り込み
      処理を解除します。



--------------------------------------------------------------------------

● ユーザー独自の水平帰線期間割り込み処理の設定

書式：void xsp_hsyncint_on(const void *time_chart);

引数：void *time_chart : ラスタ割り込み処理タイムチャートのポインタ

戻り値：無し


機能：ユーザー独自のラスタ割り込み処理を、タイムチャート（フォーマットにつ
      いては後述）により設定します。タイムチャートの内容に基づき、XSP は指
      定ラスタでの割り込み処理を発生します。

      タイムチャートで指定する割り込み処理関数は、一般の C 言語の関数で良
      く、GCC の拡張機能により割り込み処理用に記述された関数である必要はあ
      りません。アセンブラで記述したサブルーチンを割り込み処理ルーチンとし
      て指定する場合は、そのサブルーチンの終わりは rte 命令でなく、rts 命
      令として下さい。また、サブルーチン内で破壊しても良いレジスタは、d0-
      d2/a0-a2 です。それ以外のレジスタを扱う場合は、内容の退避復帰を行なっ
      て下さい。

      なお、ユーザー指定のラスタ割り込み処理は、特に処理負荷の軽いものにし
      て下さい。割り込み処理が長引き、次のラスタ割り込みが発生する時点に達
      してもその処理が終了していないような場合、スプライト表示に支障を来す
      などの弊害を生じます。

      タイムチャートのフォーマットについて説明します。タイムチャートは、構
      造体配列変数上に作成します。タイムチャート構造体 1 要素あたりのフォー
      マットは以下のようになっています。これを羅列したものをタイムチャート
      とし、本関数にて指定して下さい。

        ┌────── 先頭からのオフセット（バイト数）
        │┌───── サイズ（w : ワード、l：ロングワード）
        ││    ┌── 内容
        ↓↓    ↓

        +0.w : 割り込みラスタナンバー（-1 でタイムチャートの終点の意味）
        +2.l : 割り込み処理関数のポインタ

      タイムチャート 1 要素分の構造体は XSPlib.H 内で XSP_TIME_CHART 型と
      して宣言されています。

      タイムチャートの内容は先頭から読み取られ、逐次ラスタ割り込みの設定が
      されます。ラスタ割り込みがかかるごとに、ユーザー指定の割り込み処理関
      数が実行され、そして次のタイムチャートの内容を元に、次のラスタ割り込
      みが設定されます。割り込みラスタナンバーに -1 が指定されているとタイ
      ムチャートの終点と見なされ、ラスタ割り込み処理は終了します。次の垂直
      帰線期間が来ると、再びタイムチャートの先頭から読み取りが開始されます。

      タイムチャートの内容は先頭から読み取られ逐次実行されるので、ラスタナ
      ンバーの若い割り込み処理順になるようにタイムチャートを記述しなければ
      なりません。またタイムチャートの末端には、必ず終点（ラスタナンバーが
      -1）を記述して下さい。

      なお、割り込みラスタナンバーは、ディスプレイモード 31KHz 時は 8 の倍
      数、15KHz 時は 4 の倍数で指定して下さい。つまり、Y 座標方向 4 ドット
      おきのラスタ割り込みしか実現できないことになります。それ以外のタイミ
      ングでのラスタ割り込みを指定すると、XSP システム側のラスタ割り込みと
      衝突し、正常動作しない可能性があります。



--------------------------------------------------------------------------

● ユーザー独自の水平帰線期間割り込み処理の設定を解除

書式：void xsp_hsyncint_off(void);

戻り値：無し

機能：xsp_hsyncint_on 関数により指定されたユーザー独自のラスタ割り込み処理
      を解除します。


--------------------------------------------------------------------------

● ラスタ分割 Y 座標自動調整の on/off を指定

書式：void xsp_auto_adjust_divy(short flag);

引数：short flag : 1 のとき、自動調整モード on
                   0 のとき、自動調整モード off

戻り値：無し

機能：ラスタ分割 Y 座標自動調整モードの on/off を指定します。自動調整モード
      が on の時、沢山のスプライトが集中する箇所にラスタ分割領域を移動させ
      ることで、スプライト表示数オーバー発生を軽減します。

      ラスタ分割 Y 座標自動調整モードは、デフォルト状態で on に設定されて
      います。on の状態で発生するオーバーヘッドは極めて小さいので、常時 on
      に設定することを推奨します。


--------------------------------------------------------------------------

● ラスタ分割ブロックの縦幅最小値を指定

書式：void xsp_min_divh_set(short h);

引数：short h : 縦幅（ドット数） 有効値は 24 or 28 or 32

戻り値：無し

機能：ラスタ分割 Y 座標自動調整を行う際の、ラスタ分割ブロックの縦幅最小値
      を指定します。ラスタ分割ブロックの縦幅が小さいほど、ラスタ分割 Y 座
      標自動調整の自由度が上がるため、スプライト表示数オーバー回避効果が高
      まります。

      スプライトダブラー処理のスプライト書き換え時間確保のため、ラスタ分割
      ブロックの縦幅は最低でも 24 ドット以上必要です。また 33 以上の値に
      設定することはできません。ラスタ分割 Y 座標自動調整は 4 ドット単位で
      行なわれるため、ラスタ分割ブロックの縦幅は 4 の倍数に切り詰めて評価
      されます。このような事情から、有効値は 24 または 28 または 32 の 3 
      つのみとなっています。有効範囲外の値を指定した場合は、有効範囲内にク
      ランプされます。

      デフォルト状態では 32 が設定されています。


--------------------------------------------------------------------------

● ラスタ分割境界の Y 座標を取得

書式：short xsp_divy_get(short i);

引数：short i : ラスタ分割境界インデクス。0〜6 の範囲で指定可能。

戻り値：ラスタ分割境界の Y 座標

機能：指定したラスタ分割境界の Y 座標を取得します。
      有効範囲外の引数を指定した場合は、-1 を返します。

      本関数は、ラスタ分割 Y 座標自動調整機能の動作を確認するためのデバッ
      グ用途で用意されています。


--------------------------------------------------------------------------

● スプライト転送ラスタのオフセット値の設定

書式：void xsp_raster_ofs_for31khz_set(short ofs);     31KHz 用
      void xsp_raster_ofs_for15khz_set(short ofs);     15KHz 用

引数：short ofs : オフセット値

戻り値：無し

機能：スプライト転送ラスタのオフセット値を設定します。

      通常はデフォルト値のまま変更する必要はありません。


--------------------------------------------------------------------------

● スプライト転送ラスタのオフセット値を取得

書式：short xsp_raster_ofs_for31khz_get(void);     31KHz 用
      short xsp_raster_ofs_for15khz_get(void);     15KHz 用

戻り値：オフセット値

機能：スプライト転送ラスタのオフセット値を取得します。


==========================================================================
             複合スプライトの形状データのフォーマットについて
==========================================================================

複合スプライトの形状データは、最大 4096 パターンまで登録可能です。形状デー
タは「フレームデータ」と「リファレンスデータ」の二つで表されます。フレーム
データは、スプライトの結合のさせ方を表します。リファレンスデータは、形状
No. 別合成スプライト数と、フレームデータの参照開始アドレスを表します。


●フレームデータについて

  フレームデータは、複合スプライトを構成するスプライトを、xobj_set 関数等
  で指定された座標を基準に、どのような配置でどのようなスプライトとして表示
  するかを表すデータを構造体の配列変数上に羅列したものです。

  複合スプライトを構成する 1 個目のスプライトデータは、xobj_set 関数等で指
  定された座標からどれだけズレた位置にそのスプライトを表示するか、という
  相対座標データ "vx,vy" と、スプライト PCG パターン No. "pt" と、スプライ
  ト反転コード "rv" で表します。2 個目のスプライトのデータは、1 個目のスプ
  ライトからの相対座標データ "vx,vy" と、同じく "pt" "rv" で表します。以降
  同様に、2 個目のスプライトのデータは、2 個目のスプライトからの相対座標
  "vx,vy" と "pt" "rv" ・・・というように羅列します。

  フレームデータ構造体の 1 要素あたりのフォーマットは以下のようになってい
  ます。

  ┌────── 先頭からのオフセット（バイト数）
  │┌───── サイズ（w = ワード、l = ロングワード）
  ││    ┌── 内容
  ↓↓    ↓

  +0.w : 相対座標データ（vx）
  +2.w : 相対座標データ（vy）
  +4.w : スプライト PCG パターン No.（pt）（0〜0x7FFF）
  +6.w : 反転コード（rv）    0x0000：反転せず
                             0x4000：左右反転
                             0x8000：上下反転
                             0xC000：上下左右反転


●リファレンスデータについて

  リファレンスデータは、形状 No. 別合成スプライト数と、フレームデータの参
  照開始アドレスを表すデータを、構造体の配列変数上に羅列したものです。

  リファレンスデータ構造体の 1 要素あたりのフォーマットは以下のようになっ
  ています。

  ┌────── 先頭からのオフセット（バイト数）
  │┌───── サイズ（w = ワード、l = ロングワード）
  ││    ┌── 内容
  ↓↓    ↓

  +0.w : 合成スプライト数（num）
  +2.l : フレームデータ参照開始アドレス（ptr）
  +6.w : 未使用（unused）


  XSP2lib.H 内に、フレームデータ構造体の型 XOBJ_FRM_DAT と、リファレンス
  データ用構造体の型 XOBJ_REF_DAT が宣言されています。




==========================================================================
                             その他の注意事項
==========================================================================


●処理速度優先のため、XSP は厳重なエラーチェックを行いません。従って、不正
  な引数を指定したり、各種初期化を怠ったりした場合、動作の保証はありません。
  ご注意ください。


●表示画面サイズ 768x512 ドットモードなど、スプライト表示に対応していない
  画面モード時にスプライト表示を行うと、バスエラーが発生します。XSP はこの
  問題に対処するため、スプライト表示に対応していない画面モードでは、表示を
  自動で off にしてバスエラーを回避します。しかし、CRT レジスタをハックして
  設定した特殊な画面モードでは、スプライト表示に対応しているかの判断が難し
  くバスエラー回避に失敗することがあります。XSP 動作中は、スプライト表示に
  対応していない画面モードへの変更は避けるようにしてください。


●スプライト表示数増加のため、正確なタイミングでラスタ割り込みをかける必要
  があります。従って、他で優先度の高い割り込みが使用されていると割り込み衝
  突を起こし、スプライト表示に支障を来します。音源ドライバや PCM 多重化ド
  ライバーと併用する場合は要注意です。

  ZMUSIC を使用する場合は、ZMUSIC 常駐時にスイッチに -M を指定することで、
  これを回避できます。MCDRV の場合は、特にスイッチの指定等をしなくても、衝
  突せず動作します（さすがゲーム向けという肩書きを持つだけのことはあります
  ）。

  PCM8A と併用する場合は、垂直帰線期間割り込みが衝突します。これについては
  衝突を回避するよう、PCM8A 側の割り込みマスク設定にパッチを当てる関数
  （pcm8a_vsyncint_on／off関数）を別途用意してありますので、利用して下さい。
  なお PCM8 の場合は、このようなパッチの仕組みを持たないので、残念ながら
  XSP と併用不可能です。


●当然ですが、割り込み解除をせずにプログラムを終了すると確実に暴走します。
  プログラム終了前に必ず xsp_off 関数で割り込みを解除して下さい（インタラ
  プトスイッチやコピーキーを使って実行中止をする癖のある人は注意しましょう）


●ディスプレイ 15KHz/31KHz 以外には対応していません。




==========================================================================
               スプライト座標の固定小数点の指定方法について
==========================================================================

XSPsys.s の
   SHIFT = 0       * 座標 固定少数ビット数
は、スプライト座標の固定小数点ビット数を表しています。xsp_set 関数等により
指定された座標は、ここで指定されたビット数分、右シフトされて実際のスプライ
ト座標として使用されます。デフォルトは 0（固定小数点無し）です。




==========================================================================
                          XSP の設計指針について
==========================================================================

ここでは、XSP 設計コンセプトについて説明します。ゲームを作ろうという方々で
も特に熟練した方は、恐らくこの辺りが最も気になるところだと思います。細かい
ことは気にしないという方は、読み飛ばしていただいても結構です。


●対象ユーザーについて

  X-BASIC の sp_set 関数の機能に限界を感じている方を対象ユーザーとして想定
  しています。よって sp_set 関数から移行しやすいように、xsp_set 関数等の引
  数構成は sp_set 関数を踏襲した仕様となっています。


●記述性と自由度を重視

  記述性や自由度を犠牲にすると、代償として完成するゲームのクオリティは下が
  ります。高速化に固執した結果、記述性や自由度を損ねるような仕様のシステム
  になってしまっては本末転倒です。プログラムスタイルを強要するような仕様も
  極力避けました。


●速度面を重視

  可能な限りの高速化の術を尽くしました。最も速度が問われるループ内周部では
  恐らく 1 クロックの高速化も不可能だと思います。
  （初期化時に一度だけしか実行しない関数は、速度よりメンテナンス重視。）


●対象とするソフトについて

  XSP の当初の用途は 2D シューティングゲームでの利用でした。そのため、2D 
  シューティングゲーム向けの仕様となっています。

  優先度が 64 段階しかないので 3D のゲームには不向きです。また、バッファに
  登録したスプライトはそのフレーム中 1 回きりしか表示されないので、固定位
  置に表示し続けたいスプライトでも毎フレーム登録しなければならないことが手
  間になる利用ケースもあります。




==========================================================================
                        内部動作についての詳しい話
==========================================================================

●トリプルバッファリングについて

  xsp_set 関数、xobj_set 関数などにより表示登録されたスプライトは、xsp_out
  関数により優先度別及び y 座標別にソーティングされ、別の保存用バッファに
  保持されます。この保存用バッファに保存されたスプライト表示情報は、順に垂
  直帰線期間が来るごとに、スプライト RAM に転送され、表示されます。

  保存用バッファは、表示用・書換用・予備用の合計 3 本用意してあり、ローテー
  ションさせて使用しています。これをトリプルバッファリングと呼びます。

  トリプルバッファリングにより、垂直同期を無視したバッファローテーションが
  可能となっています。また 3 本の保存用バッファは、不安定なフレームレートを
  安定化させる緩衝作用をもたらします。ユーザープログラムが垂直同期を無視し
  たタイミングで動作しても、画面に表示する段階でタイミング調整可能なので、
  次のフレームで行うべき処理を先行処理可能になります。

  トリプルバッファリングによりもたらさせるもう一つの恩恵は、処理落ちの軽減
  です。ゲームの 1 ループの処理が垂直同期に間に合わなくても、垂直同期を無
  視したバッファローテーションが可能なので、次の垂直帰線期間まで待つ必要が
  なくなります。これにより、60fps にギリギリ間に合わないようなゲームループ
  が、一気に 30fps まで低下する現象が回避され、フレームレートが向上します。
  ただし xsp_vsync2 関数による同期を行わない場合は、この恩恵は得られないの
  で、ご注意下さい。


●スプライトダブラーについて

  走査線が通過した位置のスプライトは、すでにディスプレイ上に表示されている
  ため、移動してもそのフレーム中は表示が消えることはありません。従って、そ
  のフレーム中にそのスプライトを走査線の下側に移動することで、再度走査線を
  通過させ複数回表示させることが可能です。このようなテクニックを、「スプラ
  イトダブラー」と呼びます。

  XSP はこれをスプライト 1 枚当たり最大で 4 回繰り返し、ハードウェア上限の
  4 倍のスプライト表示を実現します（スプライトダブラーと言ってしまうと 2 倍
  どまりに聞こえるので、スプライトクアドラーとでも言った方が正確）。

  走査線が通過している最中のスプライトをさわると、どうしてもちらつきが発生
  したりノイズが表示されてしまいます。これを回避するため、XSP では 128 枚
  のスプライトを偶数ナンバーのグループと奇数ナンバーのグループに分け、片方
  のグループが表示されている間にもう一方を書き換えるという手法を用いていま
  す。

  偶数番・奇数番のペアが 4 セットあるので、画面全体は合計 8 つのブロックに
  分割されています。この分割をどのラスタで行うかは、フレーム単位で変更する
  ことが可能です。XSP では、各ブロックに含まれるスプライト数がなるべく均一
  になるように、ラスタ分割位置をフレームごとに変化させて、最適な位置を自動
  検出する処理を行います。その際、一つの分割ブロックの縦幅が、どこまで狭く
  なることを許容するかを、xsp_min_divh_set 関数で指定できます。これを狭く
  すると、スプライトが横に並びやすい横スクロールシューティングゲームなどで
  有利になります。ただし、スプライトにはハードウェアの 1 ラインの表示数限
  界があるため、分割ブロックの縦幅を狭くしすぎても表示しきれないスプライト
  が増えるだけでメリットはあまりありません。また分割ブロックを狭くしすぎる
  と、スプライトの書き換え期間が確保できなくなってしまうため、表示が乱れま
  す。このような事情から XSP の分割ブロック縦幅は、最低でも 24 ドット確保
  する仕様としています。


●ラスタ分割位置での優先度破綻を軽減する処理について

  スプライトダブラー有効時は、隣り合うラスタ分割ブロックに所属するスプライ
  ト間の優先度は正確でなくなります。XSP はこの問題を軽減するため、隣り合う
  ラスタ分割ブロック間のスプライトの上下関係を、同一の優先度を持つスプライ
  トの集団単位で調節する方法により、優先度破綻の軽減を実現しています。

  ただし、1 ラスタブロック内に使用できるスプライト数は 64 枚までなので、優
  先度破綻をどうやっても解消し切れない場合が発生します。そのような場合は仕
  方がないので、なるべく優先度の低い側のスプライトから優先度破綻させながら
  表示するようにしています。


●PCG 定義管理アルゴリズムについて

  すべてのスプライト PCG パターンに対して、PCG エリア上のどこに配置されて
  いるかを表す配置管理テーブルを用意し、これに基づいてスプライト PCG パター
  ン No. → PCG エリア No. の変換を行なっています。テーブルが PCG エリア 0
  番以外を指しているパターンは、現在 PCG RAM 上に載っています。この状態の
  PCG パターンを利用する場合、PCG パターン定義は不要です。これを PCG キャッ
  シュヒットと呼びます。一方、テーブルが PCG エリア 0 番を指しているパター
  ンは、現在 PCG RAM 上に載っていません。このような状態の PCG パターンを利
  用する場合、PCG パターン定義が必要です。これを PCG キャッシュミスと呼び
  ます。

  PCG 配置管理テーブルが 0 の時未定義とみなす仕組みの都合上、PCG エリア 0 
  番は XSP では使用できせん（もったいないですが、0 番を利用可能にすること
  によるオーバーヘッドを避けるため、現在の仕様としました。PCG エリア 0 番
  は大抵 BG 定義用に使用するので、この仕様で特に問題ないと判断しました）。

  xsp_out 関数は、スプライトの表示優先度ソーティング前段処理を行いつつ全
  PCG エリア（0〜255 番）別の使用状況を把握します。同時に、PCG キャッシュ
  ミスしたスプライトを発見した場合、そのスプライトのバッファ上アドレスを保
  存しておきます。ソーティング前段処理完了後に、キャッシュミスした PCG の
  パターン定義と、それを参照するスプライトのパッチを行います。

  新たに PCG パターンを定義するための未使用 PCG エリアを捜し出すときは注意
  が必要です。垂直表示期間中に PCG パターン定義を行う場合は、現在表示に使
  用している PCG エリアを書き換えることはできません。また次回の表示で使用
  予定の PCG エリアも書き換えることはできません。さらに 1 フレーム先行処理
  している場合は、予備用バッファのスプライトで使用している PCG エリアも書
  き換えることはできません。以上のような事情から、垂直表示期間中にパターン
  定義できる PCG エリアは、表示用・書換用・予備用の合計 3 本の保存バッファ
  いずれにおいても未使用である PCG エリアに限られます。つまり過去 3 フレー
  ム連続で未使用だった PCG エリアに限られます（逆に一度定義されたパターン
  は、最低 3 フレームの寿命があると言えます）。XSP は PCG キャッシュミスが
  発生すると、まず過去 3 フレーム以上連続で未使用の PCG エリアを捜し出し、
  垂直帰線期間を待たず PCG パターン定義を実行します。さらにもしここで過去
  3 フレーム連続で未使用の PCG エリアが一件も見つからなかった場合は（そこ
  で諦めてしまうのはもったいないので）現在表示用として使用中の PCG エリア
  も定義対象とします。ただしこの場合、表示中のものを書き換えることになるた
  め、パターン書き換えは垂直帰線期間中に行う必要があり、時間制限により最大
  31 PCG まで定義可能となっています。

  ここでもう一つの課題は、各 PCG エリアが過去 3 フレーム未使用であるかどう
  かを高速に判定する方法です。正攻法で実装すると、リンクリストを使った LRU
  アルゴリズムを使うことになります。しかし XSP ではもっと簡単な方法を使っ
  ています。各 PCG エリア毎に 1 バイトの管理領域を用意し、そこに１フレーム
  毎に更新されるフレームカウンタ値を書き込みます。カウンタ値はすぐに溢れる
  ので、定期的に（251 フレーム毎に）全テーブル要素の値をリセットします。リ
  セット時に、わずかにスパイク状に処理負荷が生じますが、それでもピーク時で
  も LRU 構造を更新するより概ね低い負荷です。3 フレーム以上未使用であるこ
  とを判定するには、テーブル上の値と、現在のフレームカウンタを比較するだけ
  で済みます。ただしこの方法では、3 フレーム以上未使用だった PCG は直ちに
  書き換えられてしまう可能性があります。LRU を用いた実装であれば、最も長く
  参照されていない PCG エリアを特定できるのに対して不利です。そこで XSP で
  は新規にパターン定義する PCG エリア番号をインクリメントさせながら循環さ
  せる方法を用います。これにより、一旦定義された PCG は、エリア番号が一巡
  するまでの十分な寿命が確保されることになります。それでもなお LRU より
  キャッシュヒット効率面で劣りますが、そのロスを上回る高速化が達成されてい
  るため、トータルでは有利となります。


●高速化のポイント

  XSP の高速化で最も重要な処理の一つがソート処理です。XSP のソートアルゴリ
  ズムは、分布数えソートです。優先度は 64 段階しか存在しないので、それぞれ
  の優先度別に件数をカウントし、ソート後の要素配置を決定します。

  分布数えソートでは、ソート後の要素列上での優先度キー変更位置が簡単に把握
  できる点が重要なメリットです。これにより、優先度キー変更位置をゼロコスト
  で検出し、スプライトダブラのラスタ分割境界上での優先度保護処理を挟み込む
  ことが低コストで可能になっています。

  分布数えソートをナイーブに実装すると、ソート一件ごとに配列データアクセス
  が必要になります。XSP ではこれを避けるため、優先度キーが連続している区間
  はテーブル引きをキャンセルする高速化を行っています。そのほかの中間値も、
  優先度キーが連続している区間はレジスタ上にキャッシュして再利用することで
  高速化しています。優先度キーは同一の値が連続しやすい傾向があるため、この
  高速化は極めてうまく機能します。

  優先度キーの変更位置は、バッファの終点を意味する end_mark を兼ねることが
  可能です。こうすることで、end_mark 検出をループの外に出すことが可能にな
  り、さらに高速化できます。具体的には以下のようにします。この疑似コードで
  示す処理は、XSP 内部実装の各所で出現します。

    for (;;) {
      ループ内処理;
      優先度キー取得;
      if (優先度キー変更なし) continue; /* 高確率で分岐 */
      if (endmark) break;
      分布数をまとめて加算;
      優先度変更処理;
      continue;
    }

  優先度キーの変更位置を検出したら、そこまでの連続要素数をバッファ上にチェ
  イン情報として記録します。ここまでがソート処理の「分布数え」部になります。
  優先度キーは xsp_set 関数等の引数 'info' が保持しますが、PCG 定義管理処
  理が 'info' をスプライトスクロールレジスタに直接設定可能な別の意味の値で
  上書きするので、それ以降は利用できなくなります。後段の処理では、優先度
  キーを利用せず、作成したチェイン情報をたどることでソートを実行しながら、
  ラスタ分割を行います。

  XSP のソート処理を高速化するにあたって、候補に上がった有力な実装案の一つ
  に、複合スプライトとして登録される一塊のスプライト群を一件の要素とみなす
  ことで、ソートを高速化するという方法がありました。しかしこれは最終的に没
  となりました。複合スプライトとして登録されたスプライトは、PCG 定義管理処
  理の際に 1 スプライト単位でスキャンされます。このスキャンの最中にオン・
  レジスタになる情報を使って、分布数えを行うことが可能であるため、優先度
  キーが連続する限り、1 スプライトあたりの分布数えのコストはインクリメント
  命令一回（4 クロック）程度であり、すでに十分な高速化が達成されています。
  複合スプライトを一括で扱う処理には、何らかのチェイン情報を別途仕込む必要
  があることがオーバーヘッドになることも考えると、導入のメリットはないと
  判断しました。



==========================================================================
         お世話になった ツール & 書籍 & 参考にさせてもらったもの
==========================================================================

  VANISHシステム                       ゆーり氏作
  HAS                                  Y.Nakamura氏作
  HLK                                  SALT氏作
  ED.R                                 S.Ueda氏作
  Inside X68000                        桑野雅彦氏著
  68000プログラマーズハンドブック      宍倉幸則氏著



==========================================================================
                                   謝辞
==========================================================================

  ご協力いただいた方々に感謝いたします。

  Jr200Okada さん



==========================================================================
                                 変更履歴
==========================================================================
◎：バグ及び不具合修正に関するもの。
●：改良点及び変更点その他に関するもの。


ver. 1.00 : (1994/8)

  ● 最大 384 枚までしか表示されなかったバージョン。その後、果てしない高速
     化への道を歩むことになる。

    （ver. 1.00〜2.00 までの過程については省略）


ver. 2.00 : (1996/8)

  ● 機能を大幅に 拡張・強化・洗練 したバージョン。


ver. 2.00 第２改訂版 : (1997/9)

  ● 本バージョンより、それまで別途配布していた複合スプライト形状データ生
     成ツール CVOBJ.X を梱包。

  ● サンプルプログラムを Ｃharlie版 GCC に対応するように修正。サンプルプ
     ログラムを拡充。XSP 自体には手を加えていない。

  ● PCG90.s PCM8Afnc.s 周りのバージョンアップ。


ver. 2.00 非公開版 : (1997/9〜時期不詳)

  ◎ 512 枚以上の表示登録があった場合、xsp_set および xsp_set_st の戻り値
     が不定になるバグを修正。

  ● xsp_pcgdat_set 関数の第一引数が、char *pcg_dat から
     const void *pcg_dat に変更。

  ● ポインタを受け取る関数の引数を、可能な限り const なポインタに変更。

  ● xsp_auto_adjust_divy/xsp_min_divh_set/xsp_divy_get 関数追加。


ver. 2.01 : (2021/1)

  ● github に移動。


ver. 2.02 : (2021/2)

  ◎ bss セクションのラベルに pc 相対アクセスしているコードの修正。

  ◎ 31KHz 時のスプライト転送ラスタを 16 ラスタ上に移動。ラスタ分割ブロッ
     クの縦幅が 32 未満の時ラスタ欠けが発生する問題が解消。

  ● xsp_raster_ofs_for31khz_set/xsp_raster_ofs_for31khz_get 関数および、
     xsp_raster_ofs_for15khz_set/xsp_raster_ofs_for15khz_get 関数を追加。


ver. 2.03 : (2023/1/2)

  ● xsp_out2 関数を追加。


ver. 2.04 : (2023/2/5)

  ● xsp_vsync_interval_set/xsp_vsync_interval_get/xsp_vsync2 関数を追加。
     旧 xsp_vsync 関数も引き続き利用できるが、obsoleted なので xsp_vsync2
     への移行を推奨。
